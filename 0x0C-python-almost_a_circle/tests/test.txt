Tasks
0. If it's not tested it doesn't work
mandatory
All your files, classes and methods must be unit tested and be PEP 8 validated.

Tous vos fichiers, classes et méthodes doivent être testés unitairement 
et être validés PEP 8.

guillaume@ubuntu:~/$ python3 -m unittest discover tests
................................................................................
................................................................................
.......................
----------------------------------------------------------------------
Ran 189 tests in 13.135s

OK
guillaume@ubuntu:~/$
Notez que ce n'est qu'un exemple. Le nombre d'épreuves
que vous créez peut être différent de l'exemple ci-dessus.

Note that this is just an example. The number of tests 
you create can be different from the above example.

Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: tests/

10. And now, the Square!
mandatory
Écrivez la classe Square qui hérite de Rectangle :

Dans le fichier models/square.py
La classe Carré hérite de Rectangle
Constructeur de classe : def __init__(self, size, x=0, y=0, id=None): :
Appelez la super classe avec id, x, y, largeur et hauteur -
ce super appel utilisera la logique du __init__
de la classe Rectangle.
La largeur et la hauteur doivent être affectées à la valeur de taille
Vous ne devez pas créer de nouveaux attributs pour cette classe,
utiliser tous les attributs de Rectangle - Pour rappel :
un carré est un rectangle de même largeur et hauteur
Toutes les validations largeur, hauteur, x et y doivent hériter de Rectangle -
même comportement en cas de données erronées
La méthode de surcharge __str__
doit renvoyer [Carré] (<id>) <x>/<y> - <taille> -
dans notre cas, largeur ou hauteur
Comme vous le savez, un carré est un rectangle spécial,
il est donc logique que cette classe Square hérite de Rectangle.
Vous avez maintenant une classe Square qui a les mêmes 
attributs et les mêmes méthodes.


Write the class Square that inherits from Rectangle:

In the file models/square.py
Class Square inherits from Rectangle
Class constructor: def __init__(self, size, x=0, y=0, id=None)::
Call the super class with id, x, y, width and height - 
this super call will use the logic of the __init__ 
of the Rectangle class. 
The width and height must be assigned to the value of size
You must not create new attributes for this class, 
use all attributes of Rectangle - As reminder: 
a Square is a Rectangle with the same width and height
All width, height, x and y validation must inherit from Rectangle - 
same behavior in case of wrong data
The overloading __str__ method 
should return [Square] (<id>) <x>/<y> - <size> - 
in our case, width or height
As you know, a Square is a special Rectangle, 
so it makes sense this class Square inherits from Rectangle. 
Now you have a Square class who has the same attributes and same methods.

guillaume@ubuntu:~/$ cat 9-main.py
#!/usr/bin/python3
""" 9-main """
from models.square import Square

if __name__ == "__main__":

    s1 = Square(5)
    print(s1)
    print(s1.area())
    s1.display()

    print("---")

    s2 = Square(2, 2)
    print(s2)
    print(s2.area())
    s2.display()

    print("---")

    s3 = Square(3, 1, 3)
    print(s3)
    print(s3.area())
    s3.display()

guillaume@ubuntu:~/$ ./9-main.py
[Square] (1) 0/0 - 5
25
#####
#####
#####
#####
#####
---
[Square] (2) 2/0 - 2
4
  ##
  ##
---
[Square] (3) 1/3 - 3
9



 ###
 ###
 ###
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/square.py
 
11. Square size
mandatory
Mettre à jour la classe Square en ajoutant la taille publique des getter et setter

Le poseur doit attribuer (dans cet ordre) la largeur et la hauteur -
avec la même valeur
Le setter doit avoir la même validation de valeur que
le Rectangle pour la largeur et la hauteur -
Pas besoin de modifier le message d'erreur d'exception
(Ce devrait être celui de la largeur)


Update the class Square by adding the public getter and setter size

The setter should assign (in this order) the width and the height - 
with the same value
The setter should have the same value validation as 
the Rectangle for width and height - 
No need to change the exception error message 
(It should be the one from width)
guillaume@ubuntu:~/$ cat 10-main.py
#!/usr/bin/python3
""" 10-main """
from models.square import Square

if __name__ == "__main__":

    s1 = Square(5)
    print(s1)
    print(s1.size)
    s1.size = 10
    print(s1)

    try:
        s1.size = "9"
    except Exception as e:
        print("[{}] {}".format(e.__class__.__name__, e))

guillaume@ubuntu:~/$ ./10-main.py
[Square] (1) 0/0 - 5
5
[Square] (1) 0/0 - 10
[TypeError] width must be an integer
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/square.py
 
12. Square update
mandatory
Mettre à jour la classe Square en ajoutant le public
method def update(self, *args, **kwargs) qui assigne des attributs :

*args est la liste des arguments - arguments sans mot-clé
Le 1er argument doit être l'attribut id
Le 2ème argument doit être l'attribut size
Le 3ème argument doit être l'attribut x
Le 4ème argument doit être l'attribut y
**kwargs peut être considéré comme un double pointeur vers un dictionnaire :
clé/valeur (arguments avec mots-clés)
**kwargs doit être ignoré si *args existe et n'est pas vide
Chaque clé de ce dictionnaire représente un attribut de l'instance


Update the class Square by adding the public 
method def update(self, *args, **kwargs) that assigns attributes:

*args is the list of arguments - no-keyworded arguments
1st argument should be the id attribute
2nd argument should be the size attribute
3rd argument should be the x attribute
4th argument should be the y attribute
**kwargs can be thought of as a double pointer to a dictionary: 
key/value (keyworded arguments)
**kwargs must be skipped if *args exists and is not empty
Each key in this dictionary represents an attribute to the instance
guillaume@ubuntu:~/$ cat 11-main.py
#!/usr/bin/python3
""" 11-main """
from models.square import Square

if __name__ == "__main__":

    s1 = Square(5)
    print(s1)

    s1.update(10)
    print(s1)

    s1.update(1, 2)
    print(s1)

    s1.update(1, 2, 3)
    print(s1)

    s1.update(1, 2, 3, 4)
    print(s1)

    s1.update(x=12)
    print(s1)

    s1.update(size=7, y=1)
    print(s1)

    s1.update(size=7, id=89, y=1)
    print(s1)

guillaume@ubuntu:~/$ ./11-main.py
[Square] (1) 0/0 - 5
[Square] (10) 0/0 - 5
[Square] (1) 0/0 - 2
[Square] (1) 3/0 - 2
[Square] (1) 3/4 - 2
[Square] (1) 12/4 - 2
[Square] (1) 12/1 - 7
[Square] (89) 12/1 - 7
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/square.py
 
13. Rectangle instance to dictionary representation
mandatory
Mettre à jour la classe Rectangle en ajoutant le public
method def to_dictionary(self): qui retourne le dictionnaire
représentation d'un Rectangle :

Ce dictionnaire doit contenir :

identifiant
largeur
la taille
X
y


Update the class Rectangle by adding the public 
method def to_dictionary(self): that returns the dictionary 
representation of a Rectangle:

This dictionary must contain:

id
width
height
x
y
guillaume@ubuntu:~/$ cat 12-main.py
#!/usr/bin/python3
""" 12-main """
from models.rectangle import Rectangle

if __name__ == "__main__":

    r1 = Rectangle(10, 2, 1, 9)
    print(r1)
    r1_dictionary = r1.to_dictionary()
    print(r1_dictionary)
    print(type(r1_dictionary))

    r2 = Rectangle(1, 1)
    print(r2)
    r2.update(**r1_dictionary)
    print(r2)
    print(r1 == r2)

guillaume@ubuntu:~/$ ./12-main.py
[Rectangle] (1) 1/9 - 10/2
{'x': 1, 'y': 9, 'id': 1, 'height': 2, 'width': 10}
<class 'dict'>
[Rectangle] (2) 0/0 - 1/1
[Rectangle] (1) 1/9 - 10/2
False
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/rectangle.py
 
14. Square instance to dictionary representation
mandatory
Mettre à jour la classe Square en ajoutant la méthode publique
def to_dictionary(self) : qui renvoie le dictionnaire
représentation d'un Carré :

Ce dictionnaire doit contenir :

identifiant
Taille
X
y


Update the class Square by adding the public method 
def to_dictionary(self): that returns the dictionary 
representation of a Square:

This dictionary must contain:

id
size
x
y
guillaume@ubuntu:~/$ cat 13-main.py
#!/usr/bin/python3
""" 13-main """
from models.square import Square

if __name__ == "__main__":

    s1 = Square(10, 2, 1)
    print(s1)
    s1_dictionary = s1.to_dictionary()
    print(s1_dictionary)
    print(type(s1_dictionary))

    s2 = Square(1, 1)
    print(s2)
    s2.update(**s1_dictionary)
    print(s2)
    print(s1 == s2)

guillaume@ubuntu:~/$ ./13-main.py
[Square] (1) 2/1 - 10
{'id': 1, 'x': 2, 'size': 10, 'y': 1}
<class 'dict'>
[Square] (2) 1/0 - 1
[Square] (1) 2/1 - 10
False
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/square.py
 
15. Dictionary to JSON string
mandatory
JSON est l'un des formats standard de partage de représentation des données.

Mettre à jour la classe Base en ajoutant la méthode statique
def to_json_string(list_dictionaries):
qui renvoie la représentation sous forme de chaîne JSON de list_dictionaries :

list_dictionaries est une liste de dictionnaires
Si list_dictionaries est None ou vide, renvoie la chaîne : "[]"
Sinon, renvoyez la représentation sous forme de chaîne JSON de list_dictionaries


JSON is one of the standard formats for sharing data representation.

Update the class Base by adding the static method 
def to_json_string(list_dictionaries): 
that returns the JSON string representation of list_dictionaries:

list_dictionaries is a list of dictionaries
If list_dictionaries is None or empty, return the string: "[]"
Otherwise, return the JSON string representation of list_dictionaries
guillaume@ubuntu:~/$ cat 14-main.py
#!/usr/bin/python3
""" 14-main """
from models.base import Base
from models.rectangle import Rectangle

if __name__ == "__main__":

    r1 = Rectangle(10, 7, 2, 8)
    dictionary = r1.to_dictionary()
    json_dictionary = Base.to_json_string([dictionary])
    print(dictionary)
    print(type(dictionary))
    print(json_dictionary)
    print(type(json_dictionary))

guillaume@ubuntu:~/$ ./14-main.py
{'x': 2, 'width': 10, 'id': 1, 'height': 7, 'y': 8}
<class 'dict'>
[{"x": 2, "width": 10, "id": 1, "height": 7, "y": 8}]
<class 'str'>
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
16. JSON string to file
mandatory
Mettre à jour la classe Base en ajoutant la méthode de classe
def save_to_file(cls, list_objs): qui écrit la chaîne JSON
représentation de list_objs dans un fichier :

list_objs est une liste d'instances qui héritent de Base -
exemple : liste d'instances Rectangle ou liste d'instances Square
Si list_objs vaut None, enregistrez une liste vide
Le nom du fichier doit être : <Class name>.json - exemple : Rectangle.json
Vous devez utiliser la méthode statique to_json_string (créée avant)
Vous devez écraser le fichier s'il existe déjà


Update the class Base by adding the class method 
def save_to_file(cls, list_objs): that writes the JSON string 
representation of list_objs to a file:

list_objs is a list of instances who inherits of Base - 
example: list of Rectangle or list of Square instances
If list_objs is None, save an empty list
The filename must be: <Class name>.json - example: Rectangle.json
You must use the static method to_json_string (created before)
You must overwrite the file if it already exists
guillaume@ubuntu:~/$ cat 15-main.py
#!/usr/bin/python3
""" 15-main """
from models.rectangle import Rectangle

if __name__ == "__main__":

    r1 = Rectangle(10, 7, 2, 8)
    r2 = Rectangle(2, 4)
    Rectangle.save_to_file([r1, r2])

    with open("Rectangle.json", "r") as file:
        print(file.read())

guillaume@ubuntu:~/$ ./15-main.py
[{"y": 8, "x": 2, "id": 1, "width": 10, "height": 7}, 
{"y": 0, "x": 0, "id": 2, "width": 2, "height": 4}]
guillaume@ubuntu:~/$
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py
 
17. JSON string to dictionary
mandatory
Mettre à jour la classe Base en ajoutant la méthode statique
def from_json_string(json_string):
qui renvoie la liste de la représentation de chaîne JSON json_string :

json_string est une chaîne représentant une liste de dictionnaires
Si json_string est None ou vide, renvoie une liste vide
Sinon, retourne la liste représentée par json_string


Update the class Base by adding the static method 
def from_json_string(json_string): 
that returns the list of the JSON string representation json_string:

json_string is a string representing a list of dictionaries
If json_string is None or empty, return an empty list
Otherwise, return the list represented by json_string
guillaume@ubuntu:~/$ cat 16-main.py
#!/usr/bin/python3
""" 16-main """
from models.rectangle import Rectangle

if __name__ == "__main__":

    list_input = [
        {'id': 89, 'width': 10, 'height': 4}, 
        {'id': 7, 'width': 1, 'height': 7}
    ]
    json_list_input = Rectangle.to_json_string(list_input)
    list_output = Rectangle.from_json_string(json_list_input)
    print("[{}] {}".format(type(list_input), list_input))
    print("[{}] {}".format(type(json_list_input), json_list_input))
    print("[{}] {}".format(type(list_output), list_output))

guillaume@ubuntu:~/$ ./16-main.py
[<class 'list'>] [{'height': 4, 'width': 10, 'id': 89}, 
{'height': 7, 'width': 1, 'id': 7}]
[<class 'str'>] [{"height": 4, "width": 10, "id": 89}, 
{"height": 7, "width": 1, "id": 7}]
[<class 'list'>] [{'height': 4, 'width': 10, 'id': 89}, 
{'height': 7, 'width': 1, 'id': 7}]
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py
 
18. Dictionary to Instance
mandatory
Mettre à jour la classe Base en ajoutant la méthode de classe
def create(cls, **dictionary): qui renvoie une instance avec
tous les attributs déjà définis :

**le dictionnaire peut être considéré comme un double pointeur vers un 
dictionnaire
Pour utiliser la méthode de mise à jour pour affecter tous les attributs,
vous devez créer une instance "factice" avant :
Créer une instance Rectangle ou Square avec "dummy"
attributs obligatoires (largeur, hauteur, taille, etc.)
Appelez la méthode d'instance de mise à jour à cette instance 
"factice" pour appliquer vos valeurs réelles
Vous devez utiliser la méthode def update(self, *args, **kwargs)
**le dictionnaire doit être utilisé comme **kwargs de la mise à jour de la méthode
Vous n'êtes pas autorisé à utiliser eval


Update the class Base by adding the class method 
def create(cls, **dictionary): that returns an instance with 
all attributes already set:

**dictionary can be thought of as a double pointer to a dictionary
To use the update method to assign all attributes, 
you must create a “dummy” instance before:
Create a Rectangle or Square instance with “dummy” 
mandatory attributes (width, height, size, etc.)
Call update instance method to this “dummy” instance to apply your real values
You must use the method def update(self, *args, **kwargs)
**dictionary must be used as **kwargs of the method update
You are not allowed to use eval
guillaume@ubuntu:~/$ cat 17-main.py
#!/usr/bin/python3
""" 17-main """
from models.rectangle import Rectangle

if __name__ == "__main__":

    r1 = Rectangle(3, 5, 1)
    r1_dictionary = r1.to_dictionary()
    r2 = Rectangle.create(**r1_dictionary)
    print(r1)
    print(r2)
    print(r1 is r2)
    print(r1 == r2)

guillaume@ubuntu:~/$ ./17-main.py
[Rectangle] (1) 1/0 - 3/5
[Rectangle] (1) 1/0 - 3/5
False
False
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py
 
19. File to instances
mandatory
Mettre à jour la classe Base en ajoutant la méthode de classe
def load_from_file(cls) : qui renvoie une liste d'instances :

Le nom du fichier doit être : <Class name>.json - exemple : Rectangle.json
Si le fichier n'existe pas, renvoie une liste vide
Sinon, renvoie une liste d'instances -
le type de ces instances dépend de cls
(classe actuelle utilisant cette méthode)
Vous devez utiliser la chaîne from_json_string et créer des méthodes
(implémenté précédemment)


Update the class Base by adding the class method 
def load_from_file(cls): that returns a list of instances:

The filename must be: <Class name>.json - example: Rectangle.json
If the file doesn’t exist, return an empty list
Otherwise, return a list of instances - 
the type of these instances depends on cls 
(current class using this method)
You must use the from_json_string and create methods 
(implemented previously)
guillaume@ubuntu:~/$ cat 18-main.py
#!/usr/bin/python3
""" 18-main """
from models.rectangle import Rectangle
from models.square import Square

if __name__ == "__main__":

    r1 = Rectangle(10, 7, 2, 8)
    r2 = Rectangle(2, 4)
    list_rectangles_input = [r1, r2]

    Rectangle.save_to_file(list_rectangles_input)

    list_rectangles_output = Rectangle.load_from_file()

    for rect in list_rectangles_input:
        print("[{}] {}".format(id(rect), rect))

    print("---")

    for rect in list_rectangles_output:
        print("[{}] {}".format(id(rect), rect))

    print("---")
    print("---")

    s1 = Square(5)
    s2 = Square(7, 9, 1)
    list_squares_input = [s1, s2]

    Square.save_to_file(list_squares_input)

    list_squares_output = Square.load_from_file()

    for square in list_squares_input:
        print("[{}] {}".format(id(square), square))

    print("---")

    for square in list_squares_output:
        print("[{}] {}".format(id(square), square))

guillaume@ubuntu:~/$ ./18-main.py
[139785912033120] [Rectangle] (1) 2/8 - 10/7
[139785912033176] [Rectangle] (2) 0/0 - 2/4
---
[139785911764752] [Rectangle] (1) 2/8 - 10/7
[139785911764808] [Rectangle] (2) 0/0 - 2/4
---
---
[139785912058040] [Square] (5) 0/0 - 5
[139785912061848] [Square] (6) 9/1 - 7
---
[139785911764976] [Square] (5) 0/0 - 5
[139785911765032] [Square] (6) 9/1 - 7
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py
 
20. JSON ok, but CSV?
#advanced
Mettre à jour la classe Base en ajoutant les méthodes de classe
def save_to_file_csv(cls, list_objs): et
def load_from_file_csv(cls) : qui sérialise et désérialise en CSV :

Le nom du fichier doit être : <Nom de la classe>.csv - exemple : Rectangle.csv
A le même comportement que la sérialisation/désérialisation JSON
Format du CSV :
Rectangle : <id>,<largeur>,<hauteur>,<x>,<y>
Carré : <id>,<taille>,<x>,<y>


Update the class Base by adding the class methods 
def save_to_file_csv(cls, list_objs): and 
def load_from_file_csv(cls): that serializes and deserializes in CSV:

The filename must be: <Class name>.csv - example: Rectangle.csv
Has the same behavior as the JSON serialization/deserialization
Format of the CSV:
Rectangle: <id>,<width>,<height>,<x>,<y>
Square: <id>,<size>,<x>,<y>
guillaume@ubuntu:~/$ cat 100-main.py
#!/usr/bin/python3
""" 100-main """
from models.rectangle import Rectangle
from models.square import Square

if __name__ == "__main__":

    r1 = Rectangle(10, 7, 2, 8)
    r2 = Rectangle(2, 4)
    list_rectangles_input = [r1, r2]

    Rectangle.save_to_file_csv(list_rectangles_input)

    list_rectangles_output = Rectangle.load_from_file_csv()

    for rect in list_rectangles_input:
        print("[{}] {}".format(id(rect), rect))

    print("---")

    for rect in list_rectangles_output:
        print("[{}] {}".format(id(rect), rect))

    print("---")
    print("---")

    s1 = Square(5)
    s2 = Square(7, 9, 1)
    list_squares_input = [s1, s2]

    Square.save_to_file_csv(list_squares_input)

    list_squares_output = Square.load_from_file_csv()

    for square in list_squares_input:
        print("[{}] {}".format(id(square), square))

    print("---")

    for square in list_squares_output:
        print("[{}] {}".format(id(square), square))

guillaume@ubuntu:~/$ ./100-main.py
[140268695797600] [Rectangle] (1) 2/8 - 10/7
[140268695797656] [Rectangle] (2) 0/0 - 2/4
---
[140268695529008] [Rectangle] (1) 2/8 - 10/7
[140268695528952] [Rectangle] (2) 0/0 - 2/4
---
---
[140268695822520] [Square] (5) 0/0 - 5
[140268695826328] [Square] (6) 9/1 - 7
---
[140268695529232] [Square] (5) 0/0 - 5
[140268695529176] [Square] (6) 9/1 - 7
guillaume@ubuntu:~/$ 
Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/
 
21. Let's draw it
#advanced
Mettre à jour la classe Base en ajoutant la méthode statique
def draw(list_rectangles, list_squares):
qui ouvre une fenêtre et dessine tous les rectangles et carrés :

Vous devez utiliser le module graphique Turtle
Pour l'installer : sudo apt-get install python3-tk
Pour rendre l'interface graphique disponible en dehors de votre machine vagabonde,
ajoutez cette ligne dans votre Vagrantfile : config.ssh.forward_x11 = true
Aucune contrainte de couleur, de forme etc… soyez créatif !


Update the class Base by adding the static method 
def draw(list_rectangles, list_squares): 
that opens a window and draws all the Rectangles and Squares:

You must use the Turtle graphics module
To install it: sudo apt-get install python3-tk
To make the GUI available outside your vagrant machine, 
add this line in your Vagrantfile: config.ssh.forward_x11 = true
No constraints for color, shape etc… be creative!
guillaume@ubuntu:~/$ cat 101-main.py
#!/usr/bin/python3
""" 101-main """
from models.base import Base
from models.rectangle import Rectangle
from models.square import Square

if __name__ == "__main__":

    list_rectangles = [Rectangle(100, 40), Rectangle(90, 110, 30, 10), 
    Rectangle(20, 25, 110, 80)]
    list_squares = [Square(35), Square(15, 70, 50), Square(80, 30, 70)]

    Base.draw(list_rectangles, list_squares)

guillaume@ubuntu:~/$ ./101-main.py
....
Ligne non commentée dans /etc/ssh/ssh_config qui disait #
ForwardX11 non et remplacez non par oui.
Puis ajouté la ligne config.ssh.forward_agent = true
à mon Vagrantfile en plus de config.ssh.forward_x11 = true.
J'ai arrêté ma vm avec un arrêt vagabond et j'ai commencé
sauvegardez-le avec vagrant up --provision puis vagrant ssh.
Si vous obtenez une erreur qui ressemble à /usr/bin/xauth :
timeout dans le fichier d'autorité de verrouillage /home/vagrant/.Xauthority,
puis entrez rm .Xauthority (vous devrez peut-être sudo).
Déconnectez-vous et redémarrez la machine virtuelle avec vagrant up --provision.
Testez avec xeyes. Si Xquartz est installé sur
le Mac OS, il devrait s'ouvrir dans une fenêtre Xquartz.
Il est de votre responsabilité de demander une révision
pour cette tâche d'un pair avant la date limite du projet.
Si aucun pair n'a été évalué,
vous devriez demander une révision à un TA ou à un membre du personnel.


Uncommented line in /etc/ssh/ssh_config that said # 
ForwardX11 no and change no to yes.
Then added line config.ssh.forward_agent = true 
to my Vagrantfile in addition to config.ssh.forward_x11 = true.
Halted my vm with vagrant halt and started 
it back up with vagrant up --provision then vagrant ssh.
If you get an error that looks like /usr/bin/xauth: 
timeout in locking authority file /home/vagrant/.Xauthority, 
then enter rm .Xauthority (you may have to sudo).
Logout and restart the vm with vagrant up --provision.
Test with xeyes. If Xquartz is installed on 
the Mac OS it should open in an Xquartz window.
It is your responsibility to request a review 
for this task from a peer before the project’s deadline. 
If no peers have been reviewed, 
you should request a review from a TA or staff member.

Repo:

GitHub repository: alx-higher_level_programming
Directory: 0x0C-python-almost_a_circle
File: models/base.py